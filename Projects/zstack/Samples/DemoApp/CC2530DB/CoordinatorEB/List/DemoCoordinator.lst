###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                22/Feb/2017  19:05:30
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c
#    Command line       =  
#        -f
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00100000 -DZDAPP_CONFIG_PAN_ID=0x0DAD
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={'H', 'O', 'G', 'E', 'S',
#        'C', 'H', 'O', 'O', 'L', 'U', 'T', 'R', 'E', 'C', 'H'}"
#        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        NV_RESTORE -D HAL_UART=TRUE -lC
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\
#        -lA
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\Obj\
#        -e --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\Source\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ol --require_prototypes
#    List file          =  
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\DemoCoordinator.lst
#    Object file        =  
#        D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\Obj\DemoCoordinator.r51
#
###############################################################################

D:\School\Jaar_3\WTWS\Projects\WirelessSensorNetworksPracticum\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c
      1          /**************************************************************************************************
      2            Filename:       DemoCoordinator.c
      3          
      4            Description:    Coordinator application for the sensor demo utilizing Simple API.
      5          
      6                            The coordinator node functions as a gateway. The node accepts
      7                            incoming reports from the sensor nodes (router and end device)
      8                            and can send the reports via the UART to a PC tool.
      9          
     10          
     11            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License").  You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product.  Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /******************************************************************************
     43           * INCLUDES
     44           */
     45          #include "sapi.h"
     46          #include "hal_key.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     47          #include "hal_led.h"
     48          #include "hal_uart.h"
     49          #include "DemoApp.h"
     50          
     51          /******************************************************************************
     52           * CONSTANTS
     53           */
     54          // General UART frame offsets
     55          #define FRAME_SOF_OFFSET                    0
     56          #define FRAME_LENGTH_OFFSET                 1
     57          #define FRAME_CMD0_OFFSET                   2
     58          #define FRAME_CMD1_OFFSET                   3
     59          #define FRAME_DATA_OFFSET                   4
     60          
     61          // ZB_RECEIVE_DATA_INDICATION offsets
     62          #define ZB_RECV_SRC_OFFSET                  0
     63          #define ZB_RECV_CMD_OFFSET                  2
     64          #define ZB_RECV_LEN_OFFSET                  4
     65          #define ZB_RECV_DATA_OFFSET                 6
     66          #define ZB_RECV_FCS_OFFSET                  8
     67          
     68          // ZB_RECEIVE_DATA_INDICATION frame length
     69          #define ZB_RECV_LENGTH                      15
     70          
     71          // PING response frame length and offset
     72          #define SYS_PING_RSP_LENGTH                 7
     73          #define SYS_PING_CMD_OFFSET                 1
     74          
     75          // Stack Profile
     76          #define ZIGBEE_2007                         0x0040
     77          #define ZIGBEE_PRO_2007                     0x0041
     78          
     79          #ifdef ZIGBEEPRO
     80          #define STACK_PROFILE                       ZIGBEE_PRO_2007
     81          #else
     82          #define STACK_PROFILE                       ZIGBEE_2007
     83          #endif
     84          
     85          #define CPT_SOP                             0xFE
     86          #define SYS_PING_REQUEST                    0x0021
     87          #define SYS_PING_RESPONSE                   0x0161
     88          #define ZB_RECEIVE_DATA_INDICATION          0x8746
     89          
     90          // Application osal event identifiers
     91          #define MY_START_EVT                        0x0001
     92          #define MY_DOOR_CHECK_EVT                   0x0002 // Event foor door check
     93          
     94          // Port and pin for door limit switch
     95          #define PORT_DOOR_LIMIT_SWITCH              0
     96          #define PIN_DOOR_LIMIT_SWITCH               5
     97          // Port and pin for green LED
     98          #define PORT_GREEN_LED                      1
     99          #define PIN_GREEN_LED                       2
    100          // Port and pin for door control
    101          #define PORT_DOOR_CONTROL                   0
    102          #define PIN_DOOR_CONTROL                    7
    103          
    104          /******************************************************************************
    105           * TYPEDEFS
    106           */
    107          typedef struct
    108          {
    109            uint16              source;
    110            uint16              parent;
    111            uint8               temp;
    112            uint8               voltage;
    113          } gtwData_t;
    114          
    115          /******************************************************************************
    116           * LOCAL VARIABLES
    117           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          static uint8 appState =             APP_INIT;
   \                     appState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    119          static uint8 myStartRetryDelay =    10;          // milliseconds
   \                     myStartRetryDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for myStartRetryDelay>`
   \   000001                REQUIRE __INIT_XDATA_I
    120          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    121          static uint8 myDoorCheckDelay =     100;         // milliseconds
   \                     myDoorCheckDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for myDoorCheckDelay>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    122          static uint8 prevDoorCheckVal;
   \                     prevDoorCheckVal:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    123          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    124          static gtwData_t gtwData;
   \                     gtwData:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    125          
    126          /******************************************************************************
    127           * LOCAL FUNCTIONS
    128           */
    129          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    130          static void sysPingReqRcvd(void);
    131          static void sysPingRsp(void);
    132          static void sendGtwReport(gtwData_t *gtwData);
    133          
    134          /******************************************************************************
    135           * GLOBAL VARIABLES
    136           */
    137          // Inputs and Outputs for Collector device
    138          #define NUM_OUT_CMD_COLLECTOR           0
    139          #define NUM_IN_CMD_COLLECTOR            1
    140          
    141          // List of output and input commands for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    142          const cId_t zb_InCmdList[NUM_IN_CMD_COLLECTOR] =
   \                     zb_InCmdList:
   \   000000   0200         DW 2
    143          {
    144            SENSOR_REPORT_CMD_ID,
    145          };
    146          
    147          // Define SimpleDescriptor for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    148          const SimpleDescriptionFormat_t zb_SimpleDesc =
   \                     zb_SimpleDesc:
   \   000000   02           DB 2
   \   000001   200F         DW 3872
   \   000003   0200         DW 2
   \   000005   01           DB 1
   \   000006   01           DB 1
   \   000007   ....         DW zb_InCmdList
   \   000009   00           DB 0
   \   00000A   0000         DW 0H
    149          {
    150            MY_ENDPOINT_ID,             //  Endpoint
    151            MY_PROFILE_ID,              //  Profile ID
    152            DEV_ID_COLLECTOR,           //  Device ID
    153            DEVICE_VERSION_COLLECTOR,   //  Device Version
    154            0,                          //  Reserved
    155            NUM_IN_CMD_COLLECTOR,       //  Number of Input Commands
    156            (cId_t *) zb_InCmdList,     //  Input Command List
    157            NUM_OUT_CMD_COLLECTOR,      //  Number of Output Commands
    158            (cId_t *) NULL              //  Output Command List
    159          };
    160          
    161          /******************************************************************************
    162           * GLOBAL FUNCTIONS
    163           */
    164          
    165          /******************************************************************************
    166           * @fn          zb_HandleOsalEvent
    167           *
    168           * @brief       The zb_HandleOsalEvent function is called by the operating
    169           *              system when a task event is set
    170           *
    171           * @param       event - Bitmask containing the events that have been set
    172           *
    173           * @return      none
    174           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    175          void zb_HandleOsalEvent( uint16 event )
   \                     zb_HandleOsalEvent:
    176          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    177            if( event & SYS_EVENT_MSG )
    178            {
    179            }
    180          
    181            if( event & ZB_ENTRY_EVENT )
   \   000009   EE           MOV     A,R6
   \   00000A   5400         ANL     A,#0x0
   \   00000C   F8           MOV     R0,A
   \   00000D   EF           MOV     A,R7
   \   00000E   5410         ANL     A,#0x10
   \   000010   F9           MOV     R1,A
   \   000011   E8           MOV     A,R0
   \   000012   49           ORL     A,R1
   \   000013   6036         JZ      ??zb_HandleOsalEvent_0
    182            {
    183              /* If we get this event, then we can initialise things */
    184              
    185              // Initialise UART
    186              initUart(uartRxCB);
   \   000015                ; Setup parameters for call to function initUart
   \   000015   7A..         MOV     R2,#`??uartRxCB::?relay` & 0xff
   \   000017   7B..         MOV     R3,#(`??uartRxCB::?relay` >> 8) & 0xff
   \   000019   12....       LCALL   `??initUart::?relay` ; Banked call to: initUart
    187              
    188              // Initialise the door limit switch as input and internal pull-up activated
    189              //MCU_IO_INPUT( PORT_DOOR_LIMIT_SWITCH, PIN_DOOR_LIMIT_SWITCH, MCU_IO_PULLUP );
    190              MCU_IO_DIR_INPUT( PORT_DOOR_LIMIT_SWITCH, PIN_DOOR_LIMIT_SWITCH );
   \   00001C   53FDDF       ANL     0xfd,#0xdf
    191              // Initialise the green LED as output
    192              MCU_IO_DIR_OUTPUT( PORT_GREEN_LED, PIN_GREEN_LED );
   \   00001F   43FE04       ORL     0xfe,#0x4
    193              // Initialise the door control as output
    194              MCU_IO_DIR_OUTPUT( PORT_DOOR_CONTROL, PIN_DOOR_CONTROL );
   \   000022   43FD80       ORL     0xfd,#0x80
    195              
    196              // Set the previous door check value
    197              prevDoorCheckVal = MCU_IO_GET( PORT_DOOR_LIMIT_SWITCH, PIN_DOOR_LIMIT_SWITCH );
   \   000025   E580         MOV     A,0x80
   \   000027   5420         ANL     A,#0x20
   \   000029   90....       MOV     DPTR,#prevDoorCheckVal
   \   00002C   F0           MOVX    @DPTR,A
    198          
    199              // blind LED 1 to indicate starting/joining a network
    200              HalLedBlink ( HAL_LED_1, 0, 50, 500 );
   \   00002D                ; Setup parameters for call to function HalLedBlink
   \   00002D   7CF4         MOV     R4,#-0xc
   \   00002F   7D01         MOV     R5,#0x1
   \   000031   7B32         MOV     R3,#0x32
   \   000033   7A00         MOV     R2,#0x0
   \   000035   7901         MOV     R1,#0x1
   \   000037   12....       LCALL   `??HalLedBlink::?relay`; Banked call to: HalLedBlink
    201              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   00003A                ; Setup parameters for call to function HalLedSet
   \   00003A   7A00         MOV     R2,#0x0
   \   00003C   7902         MOV     R1,#0x2
   \   00003E   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   000041   E9           MOV     A,R1
    202          
    203              // Start the device
    204              appState = APP_START;
   \   000042   90....       MOV     DPTR,#appState
   \   000045   7401         MOV     A,#0x1
   \   000047   F0           MOVX    @DPTR,A
    205              zb_StartRequest();
   \   000048                ; Setup parameters for call to function zb_StartRequest
   \   000048   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    206            }
    207          
    208            if ( event & MY_START_EVT )
   \                     ??zb_HandleOsalEvent_0:
   \   00004B   EE           MOV     A,R6
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   5003         JNC     ??zb_HandleOsalEvent_1
    209            {
    210              zb_StartRequest();
   \   000050                ; Setup parameters for call to function zb_StartRequest
   \   000050   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    211            }
    212            
    213            if ( event & MY_DOOR_CHECK_EVT ) 
   \                     ??zb_HandleOsalEvent_1:
   \   000053   EE           MOV     A,R6
   \   000054   5402         ANL     A,#0x2
   \   000056   602C         JZ      ??zb_HandleOsalEvent_2
    214            {
    215              // Check if the door limit switch has changed
    216              uint8 doorCheckVal = MCU_IO_GET( PORT_DOOR_LIMIT_SWITCH, PIN_DOOR_LIMIT_SWITCH );
   \   000058   E580         MOV     A,0x80
   \   00005A   5420         ANL     A,#0x20
   \   00005C   F9           MOV     R1,A
    217              if ( prevDoorCheckVal != doorCheckVal ) {
   \   00005D   90....       MOV     DPTR,#prevDoorCheckVal
   \   000060   E0           MOVX    A,@DPTR
   \   000061   69           XRL     A,R1
   \   000062   6020         JZ      ??zb_HandleOsalEvent_2
    218                // Set the green LED
    219                MCU_IO_SET(
    220                     PORT_GREEN_LED,
    221                     PIN_GREEN_LED,
    222                     doorCheckVal > 0
    223                );
   \   000064   E9           MOV     A,R1
   \   000065   6004         JZ      ??zb_HandleOsalEvent_3
   \   000067   7801         MOV     R0,#0x1
   \   000069   8002         SJMP    ??zb_HandleOsalEvent_4
   \                     ??zb_HandleOsalEvent_3:
   \   00006B   7800         MOV     R0,#0x0
   \                     ??zb_HandleOsalEvent_4:
   \   00006D   E8           MOV     A,R0
   \   00006E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000070   9292         MOV     0x90.2,C
    224                
    225                prevDoorCheckVal = doorCheckVal;
   \   000072   E9           MOV     A,R1
   \   000073   90....       MOV     DPTR,#prevDoorCheckVal
   \   000076   F0           MOVX    @DPTR,A
    226                
    227                // No longer have to check whether or not the door limit switch changes, 
    228                // so stop the timer
    229                osal_stop_timerEx( sapi_TaskID, MY_DOOR_CHECK_EVT );
   \   000077                ; Setup parameters for call to function osal_stop_timerEx
   \   000077   7A02         MOV     R2,#0x2
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   90....       MOV     DPTR,#sapi_TaskID
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F9           MOV     R1,A
   \   000080   12....       LCALL   `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   \   000083   E9           MOV     A,R1
    230              }
    231            }
    232          }
   \                     ??zb_HandleOsalEvent_2:
   \   000084   7F01         MOV     R7,#0x1
   \   000086   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000089                REQUIRE P0DIR
   \   000089                REQUIRE P1DIR
   \   000089                REQUIRE _A_P0
   \   000089                REQUIRE _A_P1
    233          
    234          /******************************************************************************
    235           * @fn      zb_HandleKeys
    236           *
    237           * @brief   Handles all key events for this device.
    238           *
    239           * @param   shift - true if in shift/alt.
    240           * @param   keys - bit field for key events. Valid entries:
    241           *                 EVAL_SW4
    242           *                 EVAL_SW3
    243           *                 EVAL_SW2
    244           *                 EVAL_SW1
    245           *
    246           * @return  none
    247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    248          void zb_HandleKeys( uint8 shift, uint8 keys )
   \                     zb_HandleKeys:
    249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
    250            static uint8 allowBind = FALSE;
    251          
    252            /* shift is not used and keys HAL_KEY_SW_3 and HAL_KEY_SW_4 are not used, so 
    253             * removed code
    254             */
    255            
    256            if ( keys & HAL_KEY_SW_1 )
   \   000007   EE           MOV     A,R6
   \   000008   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000A   5031         JNC     ??zb_HandleKeys_0
    257            {    
    258              if ( appState == APP_RUN )
   \   00000C   90....       MOV     DPTR,#appState
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6404         XRL     A,#0x4
   \   000012   7029         JNZ     ??zb_HandleKeys_0
    259              {
    260                allowBind ^= 1;
   \   000014   90....       MOV     DPTR,#??allowBind
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   F0           MOVX    @DPTR,A
    261                if ( allowBind )
   \   00001B   90....       MOV     DPTR,#??allowBind
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   600F         JZ      ??zb_HandleKeys_1
    262                {
    263                  // Turn ON Allow Bind mode infinitly
    264                  zb_AllowBind( 0xFF );
   \   000021                ; Setup parameters for call to function zb_AllowBind
   \   000021   79FF         MOV     R1,#-0x1
   \   000023   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    265                  HalLedSet( HAL_LED_2, HAL_LED_MODE_ON );
   \   000026                ; Setup parameters for call to function HalLedSet
   \   000026   7A01         MOV     R2,#0x1
   \   000028   7902         MOV     R1,#0x2
   \   00002A   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   00002D   E9           MOV     A,R1
   \   00002E   800D         SJMP    ??zb_HandleKeys_0
    266                }
    267                else
    268                {
    269                  // Turn OFF Allow Bind mode infinitly
    270                  zb_AllowBind( 0x00 );
   \                     ??zb_HandleKeys_1:
   \   000030                ; Setup parameters for call to function zb_AllowBind
   \   000030   7900         MOV     R1,#0x0
   \   000032   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    271                  HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   000035                ; Setup parameters for call to function HalLedSet
   \   000035   7A00         MOV     R2,#0x0
   \   000037   7902         MOV     R1,#0x2
   \   000039   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   00003C   E9           MOV     A,R1
    272                }
    273              }
    274            }
    275            if ( keys & HAL_KEY_SW_2 )
   \                     ??zb_HandleKeys_0:
   \   00003D   EE           MOV     A,R6
   \   00003E   A2E1         MOV     C,0xE0 /* A   */.1
   \   000040   5045         JNC     ??zb_HandleKeys_2
    276            {   
    277              // Open or close the door depending on the current value of the door limit 
    278              // switch and depending on whether or not we're currently running
    279              if ( appState == APP_RUN ) 
   \   000042   90....       MOV     DPTR,#appState
   \   000045   E0           MOVX    A,@DPTR
   \   000046   6404         XRL     A,#0x4
   \   000048   703D         JNZ     ??zb_HandleKeys_2
    280              {      
    281                /* TODO: Might not need to get the value at this point as we do this in 
    282                 * the ZB_ENTRY_EVENT and the MY_DOOR_CHECK_EVT as well
    283                 */
    284                // Set the door control to the value we receive from the port and pin of 
    285                // the door limit switch. 
    286                prevDoorCheckVal = MCU_IO_GET( PORT_DOOR_LIMIT_SWITCH, PIN_DOOR_LIMIT_SWITCH );
   \   00004A   E580         MOV     A,0x80
   \   00004C   5420         ANL     A,#0x20
   \   00004E   90....       MOV     DPTR,#prevDoorCheckVal
   \   000051   F0           MOVX    @DPTR,A
    287                MCU_IO_SET(
    288                     PORT_DOOR_CONTROL,
    289                     PIN_DOOR_CONTROL,
    290                     // Note that the value returned by MCU_IO_GET() may be higher than 1 
    291                     // (0x20 in our case), so we simply check if the returned value is 
    292                     // positive
    293                     prevDoorCheckVal > 0
    294                );
   \   000052   90....       MOV     DPTR,#prevDoorCheckVal
   \   000055   E0           MOVX    A,@DPTR
   \   000056   6004         JZ      ??zb_HandleKeys_3
   \   000058   7801         MOV     R0,#0x1
   \   00005A   8002         SJMP    ??zb_HandleKeys_4
   \                     ??zb_HandleKeys_3:
   \   00005C   7800         MOV     R0,#0x0
   \                     ??zb_HandleKeys_4:
   \   00005E   E8           MOV     A,R0
   \   00005F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000061   9287         MOV     0x80.7,C
    295                
    296                // Make sure there's a reload timer running for the MY_DOOR_CHECK_EVT so 
    297                // the green LED gets updated
    298                osal_start_reload_timer( sapi_TaskID, MY_DOOR_CHECK_EVT, myDoorCheckDelay );
   \   000063                ; Setup parameters for call to function osal_start_reload_timer
   \   000063   90....       MOV     DPTR,#myDoorCheckDelay
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F5..         MOV     ?V0,A
   \   000069   E4           CLR     A
   \   00006A   F5..         MOV     ?V1,A
   \   00006C   F5..         MOV     ?V2,A
   \   00006E   F5..         MOV     ?V3,A
   \   000070   78..         MOV     R0,#?V0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000075   7A02         MOV     R2,#0x2
   \   000077   7B00         MOV     R3,#0x0
   \   000079   90....       MOV     DPTR,#sapi_TaskID
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F9           MOV     R1,A
   \   00007E   12....       LCALL   `??osal_start_reload_timer::?relay`; Banked call to: osal_start_reload_timer
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   \   000086   E9           MOV     A,R1
    299              }
    300            }
    301          }
   \                     ??zb_HandleKeys_2:
   \   000087   7F04         MOV     R7,#0x4
   \   000089   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00008C                REQUIRE _A_P0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??allowBind:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    302          
    303          /******************************************************************************
    304           * @fn          zb_StartConfirm
    305           *
    306           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    307           *              after a start request operation completes
    308           *
    309           * @param       status - The status of the start operation.  Status of
    310           *                       ZB_SUCCESS indicates the start operation completed
    311           *                       successfully.  Else the status is an error code.
    312           *
    313           * @return      none
    314           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    315          void zb_StartConfirm( uint8 status )
   \                     zb_StartConfirm:
    316          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    317            // If the device sucessfully started, change state to running
    318            if ( status == ZB_SUCCESS )
   \   000007   EE           MOV     A,R6
   \   000008   7010         JNZ     ??zb_StartConfirm_0
    319            {
    320              // Set LED 1 to indicate that node is operational on the network
    321              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
   \   00000A                ; Setup parameters for call to function HalLedSet
   \   00000A   7A01         MOV     R2,#0x1
   \   00000C   7901         MOV     R1,#0x1
   \   00000E   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   000011   E9           MOV     A,R1
    322          
    323              // Change application state
    324              appState = APP_RUN;
   \   000012   90....       MOV     DPTR,#appState
   \   000015   7404         MOV     A,#0x4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   8024         SJMP    ??zb_StartConfirm_1
    325            }
    326            else
    327            {
    328              // Try again later with a delay
    329              osal_start_timerEx( sapi_TaskID, MY_START_EVT, myStartRetryDelay );
   \                     ??zb_StartConfirm_0:
   \   00001A                ; Setup parameters for call to function osal_start_timerEx
   \   00001A   90....       MOV     DPTR,#myStartRetryDelay
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F5..         MOV     ?V0,A
   \   000020   E4           CLR     A
   \   000021   F5..         MOV     ?V1,A
   \   000023   F5..         MOV     ?V2,A
   \   000025   F5..         MOV     ?V3,A
   \   000027   78..         MOV     R0,#?V0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00002C   7A01         MOV     R2,#0x1
   \   00002E   7B00         MOV     R3,#0x0
   \   000030   90....       MOV     DPTR,#sapi_TaskID
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D   E9           MOV     A,R1
    330            }
    331          }
   \                     ??zb_StartConfirm_1:
   \   00003E   7F04         MOV     R7,#0x4
   \   000040   02....       LJMP    ?BANKED_LEAVE_XDATA
    332          
    333          /******************************************************************************
    334           * @fn          zb_SendDataConfirm
    335           *
    336           * @brief       The zb_SendDataConfirm callback function is called by the
    337           *              ZigBee stack after a send data operation completes
    338           *
    339           * @param       handle - The handle identifying the data transmission.
    340           *              status - The status of the operation.
    341           *
    342           * @return      none
    343           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    344          void zb_SendDataConfirm( uint8 handle, uint8 status )
   \                     zb_SendDataConfirm:
    345          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    346            (void)handle;
    347            (void)status;
    348          }
   \   000000   02....       LJMP    ?BRET
    349          
    350          /******************************************************************************
    351           * @fn          zb_BindConfirm
    352           *
    353           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    354           *              after a bind operation completes.
    355           *
    356           * @param       commandId - The command ID of the binding being confirmed.
    357           *              status - The status of the bind operation.
    358           *
    359           * @return      none
    360           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    361          void zb_BindConfirm( uint16 commandId, uint8 status )
   \                     zb_BindConfirm:
    362          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    363            (void)commandId;
    364            (void)status;
    365          }
   \   000000   02....       LJMP    ?BRET
    366          
    367          /******************************************************************************
    368           * @fn          zb_AllowBindConfirm
    369           *
    370           * @brief       Indicates when another device attempted to bind to this device
    371           *
    372           * @param
    373           *
    374           * @return      none
    375           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    376          void zb_AllowBindConfirm( uint16 source )
   \                     zb_AllowBindConfirm:
    377          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    378            (void)source;
    379          }
   \   000000   02....       LJMP    ?BRET
    380          
    381          /******************************************************************************
    382           * @fn          zb_FindDeviceConfirm
    383           *
    384           * @brief       The zb_FindDeviceConfirm callback function is called by the
    385           *              ZigBee stack when a find device operation completes.
    386           *
    387           * @param       searchType - The type of search that was performed.
    388           *              searchKey - Value that the search was executed on.
    389           *              result - The result of the search.
    390           *
    391           * @return      none
    392           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    393          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
   \                     zb_FindDeviceConfirm:
    394          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    395            (void)searchType;
    396            (void)searchKey;
    397            (void)result;
    398          }
   \   000000   02....       LJMP    ?BRET
    399          
    400          /******************************************************************************
    401           * @fn          zb_ReceiveDataIndication
    402           *
    403           * @brief       The zb_ReceiveDataIndication callback function is called
    404           *              asynchronously by the ZigBee stack to notify the application
    405           *              when data is received from a peer device.
    406           *
    407           * @param       source - The short address of the peer device that sent the data
    408           *              command - The commandId associated with the data
    409           *              len - The number of bytes in the pData parameter
    410           *              pData - The data sent by the peer device
    411           *
    412           * @return      none
    413           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    414          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
    415          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740B         MOV     A,#0xb
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
    416            (void)command;
    417            (void)len;
    418          
    419            gtwData.parent = BUILD_UINT16(pData[SENSOR_PARENT_OFFSET+1], pData[SENSOR_PARENT_OFFSET]);
   \   00000F   8882         MOV     DPL,R0
   \   000011   8983         MOV     DPH,R1
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FE           MOV     R6,A
   \   000018   7F00         MOV     R7,#0x0
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FC           MOV     R4,A
   \   000022   7D00         MOV     R5,#0x0
   \   000024   E4           CLR     A
   \   000025   CC           XCH     A,R4
   \   000026   FD           MOV     R5,A
   \   000027   EE           MOV     A,R6
   \   000028   2C           ADD     A,R4
   \   000029   FC           MOV     R4,A
   \   00002A   EF           MOV     A,R7
   \   00002B   3D           ADDC    A,R5
   \   00002C   FD           MOV     R5,A
   \   00002D   90....       MOV     DPTR,#gtwData + 2
   \   000030   EC           MOV     A,R4
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   ED           MOV     A,R5
   \   000034   F0           MOVX    @DPTR,A
    420            gtwData.source = source;
   \   000035   90....       MOV     DPTR,#gtwData
   \   000038   EA           MOV     A,R2
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   EB           MOV     A,R3
   \   00003C   F0           MOVX    @DPTR,A
    421            gtwData.temp = *pData;
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   E0           MOVX    A,@DPTR
   \   000042   90....       MOV     DPTR,#gtwData + 4
   \   000045   F0           MOVX    @DPTR,A
    422            gtwData.voltage = *(pData+SENSOR_VOLTAGE_OFFSET);
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   90....       MOV     DPTR,#gtwData + 5
   \   00004F   F0           MOVX    @DPTR,A
    423          
    424            // Flash LED 2 once to indicate data reception
    425            HalLedSet ( HAL_LED_2, HAL_LED_MODE_FLASH );
   \   000050                ; Setup parameters for call to function HalLedSet
   \   000050   7A04         MOV     R2,#0x4
   \   000052   7902         MOV     R1,#0x2
   \   000054   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   000057   E9           MOV     A,R1
    426          
    427            // Send gateway report
    428            sendGtwReport(&gtwData);
   \   000058                ; Setup parameters for call to function sendGtwReport
   \   000058   7A..         MOV     R2,#gtwData & 0xff
   \   00005A   7B..         MOV     R3,#(gtwData >> 8) & 0xff
   \   00005C   12....       LCALL   `??sendGtwReport::?relay`; Banked call to: sendGtwReport
    429          }
   \   00005F   7F01         MOV     R7,#0x1
   \   000061   02....       LJMP    ?BANKED_LEAVE_XDATA
    430          
    431          /******************************************************************************
    432           * @fn          uartRxCB
    433           *
    434           * @brief       Callback function for UART
    435           *
    436           * @param       port - UART port
    437           *              event - UART event that caused callback
    438           *
    439           * @return      none
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          void uartRxCB( uint8 port, uint8 event )
   \                     uartRxCB:
    442          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 128
   \   000005   7480         MOV     A,#-0x80
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    443            (void)port;
    444          
    445            uint8 pBuf[RX_BUF_LEN];
    446            uint16 cmd;
    447            uint16 len;
    448          
    449            if ( event != HAL_UART_TX_EMPTY )
   \   00000C   7410         MOV     A,#0x10
   \   00000E   6E           XRL     A,R6
   \   00000F   604C         JZ      ??uartRxCB_0
    450            {
    451              // Read from UART
    452              len = HalUARTRead( HAL_UART_PORT_0, pBuf, RX_BUF_LEN );
   \   000011                ; Setup parameters for call to function HalUARTRead
   \   000011   7C80         MOV     R4,#-0x80
   \   000013   7D00         MOV     R5,#0x0
   \   000015   AA..         MOV     R2,?XSP + 0
   \   000017   AB..         MOV     R3,?XSP + 1
   \   000019   7900         MOV     R1,#0x0
   \   00001B   12....       LCALL   `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   00001E   8A..         MOV     ?V0,R2
   \   000020   8B..         MOV     ?V1,R3
   \   000022   A8..         MOV     R0,?V0
   \   000024   A9..         MOV     R1,?V1
    453          
    454              if ( len > 0 )
   \   000026   E8           MOV     A,R0
   \   000027   49           ORL     A,R1
   \   000028   6033         JZ      ??uartRxCB_0
    455              {
    456                cmd = BUILD_UINT16(pBuf[SYS_PING_CMD_OFFSET + 1], pBuf[SYS_PING_CMD_OFFSET]);
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   7B00         MOV     R3,#0x0
   \   000033   7401         MOV     A,#0x1
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F8           MOV     R0,A
   \   00003A   7900         MOV     R1,#0x0
   \   00003C   E4           CLR     A
   \   00003D   C8           XCH     A,R0
   \   00003E   F9           MOV     R1,A
   \   00003F   EA           MOV     A,R2
   \   000040   28           ADD     A,R0
   \   000041   F8           MOV     R0,A
   \   000042   EB           MOV     A,R3
   \   000043   39           ADDC    A,R1
   \   000044   F9           MOV     R1,A
    457          
    458                if( (pBuf[FRAME_SOF_OFFSET] == CPT_SOP) && (cmd == SYS_PING_REQUEST) )
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   64FE         XRL     A,#0xfe
   \   00004E   700D         JNZ     ??uartRxCB_0
   \   000050   7421         MOV     A,#0x21
   \   000052   68           XRL     A,R0
   \   000053   7003         JNZ     ??uartRxCB_1
   \   000055   7400         MOV     A,#0x0
   \   000057   69           XRL     A,R1
   \                     ??uartRxCB_1:
   \   000058   7003         JNZ     ??uartRxCB_0
    459                {
    460                  sysPingReqRcvd();
   \   00005A                ; Setup parameters for call to function sysPingReqRcvd
   \   00005A   12....       LCALL   `??sysPingReqRcvd::?relay`; Banked call to: sysPingReqRcvd
    461                }
    462              }
    463            }
    464          }
   \                     ??uartRxCB_0:
   \   00005D   7480         MOV     A,#-0x80
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   7F02         MOV     R7,#0x2
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
    465          
    466          /******************************************************************************
    467           * @fn          sysPingReqRcvd
    468           *
    469           * @brief       Ping request received
    470           *
    471           * @param       none
    472           *
    473           * @return      none
    474           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    475          static void sysPingReqRcvd(void)
   \                     sysPingReqRcvd:
    476          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    477             sysPingRsp();
   \   000004                ; Setup parameters for call to function sysPingRsp
   \   000004   12....       LCALL   `??sysPingRsp::?relay`; Banked call to: sysPingRsp
    478          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    479          
    480          /******************************************************************************
    481           * @fn          sysPingRsp
    482           *
    483           * @brief       Build and send Ping response
    484           *
    485           * @param       none
    486           *
    487           * @return      none
    488           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    489          static void sysPingRsp(void)
   \                     sysPingRsp:
    490          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 7
   \   000004   74F9         MOV     A,#-0x7
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    491            uint8 pBuf[SYS_PING_RSP_LENGTH];
    492          
    493            // Start of Frame Delimiter
    494            pBuf[FRAME_SOF_OFFSET] = CPT_SOP;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   74FE         MOV     A,#-0x2
   \   000011   F0           MOVX    @DPTR,A
    495          
    496            // Length
    497            pBuf[FRAME_LENGTH_OFFSET] = 2;
   \   000012   7401         MOV     A,#0x1
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   7402         MOV     A,#0x2
   \   000019   F0           MOVX    @DPTR,A
    498          
    499            // Command type
    500            pBuf[FRAME_CMD0_OFFSET] = LO_UINT16(SYS_PING_RESPONSE);
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   7461         MOV     A,#0x61
   \   000021   F0           MOVX    @DPTR,A
    501            pBuf[FRAME_CMD1_OFFSET] = HI_UINT16(SYS_PING_RESPONSE);
   \   000022   7403         MOV     A,#0x3
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   7401         MOV     A,#0x1
   \   000029   F0           MOVX    @DPTR,A
    502          
    503            // Stack profile
    504            pBuf[FRAME_DATA_OFFSET] = LO_UINT16(STACK_PROFILE);
   \   00002A   7404         MOV     A,#0x4
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   7441         MOV     A,#0x41
   \   000031   F0           MOVX    @DPTR,A
    505            pBuf[FRAME_DATA_OFFSET + 1] = HI_UINT16(STACK_PROFILE);
   \   000032   7405         MOV     A,#0x5
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   7400         MOV     A,#0x0
   \   000039   F0           MOVX    @DPTR,A
    506          
    507            // Frame Check Sequence
    508            pBuf[SYS_PING_RSP_LENGTH - 1] = calcFCS(&pBuf[FRAME_LENGTH_OFFSET], (SYS_PING_RSP_LENGTH - 2));
   \   00003A                ; Setup parameters for call to function calcFCS
   \   00003A   7905         MOV     R1,#0x5
   \   00003C   7401         MOV     A,#0x1
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   AA82         MOV     R2,DPL
   \   000043   AB83         MOV     R3,DPH
   \   000045   12....       LCALL   `??calcFCS::?relay`  ; Banked call to: calcFCS
   \   000048   E9           MOV     A,R1
   \   000049   C0E0         PUSH    A
   \   00004B   7406         MOV     A,#0x6
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   D0E0         POP     A
   \   000052   F0           MOVX    @DPTR,A
    509          
    510            // Write frame to UART
    511            HalUARTWrite(HAL_UART_PORT_0,pBuf, SYS_PING_RSP_LENGTH);
   \   000053                ; Setup parameters for call to function HalUARTWrite
   \   000053   7C07         MOV     R4,#0x7
   \   000055   7D00         MOV     R5,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   12....       LCALL   `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    512          }
   \   000060   7407         MOV     A,#0x7
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
   \   000065   D083         POP     DPH
   \   000067   D082         POP     DPL
   \   000069   02....       LJMP    ?BRET
    513          
    514          /******************************************************************************
    515           * @fn          sendGtwReport
    516           *
    517           * @brief       Build and send gateway report
    518           *
    519           * @param       none
    520           *
    521           * @return      none
    522           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    523          static void sendGtwReport(gtwData_t *gtwData)
   \                     sendGtwReport:
    524          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 15
   \   000004   74F1         MOV     A,#-0xf
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    525            uint8 pFrame[ZB_RECV_LENGTH];
    526          
    527            // Start of Frame Delimiter
    528            pFrame[FRAME_SOF_OFFSET] = CPT_SOP; // Start of Frame Delimiter
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   74FE         MOV     A,#-0x2
   \   000011   F0           MOVX    @DPTR,A
    529          
    530            // Length
    531            pFrame[FRAME_LENGTH_OFFSET] = 10;
   \   000012   7401         MOV     A,#0x1
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   740A         MOV     A,#0xa
   \   000019   F0           MOVX    @DPTR,A
    532          
    533            // Command type
    534            pFrame[FRAME_CMD0_OFFSET] = LO_UINT16(ZB_RECEIVE_DATA_INDICATION);
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   7446         MOV     A,#0x46
   \   000021   F0           MOVX    @DPTR,A
    535            pFrame[FRAME_CMD1_OFFSET] = HI_UINT16(ZB_RECEIVE_DATA_INDICATION);
   \   000022   7403         MOV     A,#0x3
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   7487         MOV     A,#-0x79
   \   000029   F0           MOVX    @DPTR,A
    536          
    537            // Source address
    538            pFrame[FRAME_DATA_OFFSET + ZB_RECV_SRC_OFFSET] = LO_UINT16(gtwData->source);
   \   00002A   8A82         MOV     DPL,R2
   \   00002C   8B83         MOV     DPH,R3
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   C0E0         PUSH    A
   \   000036   7404         MOV     A,#0x4
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   D0E0         POP     A
   \   00003D   F0           MOVX    @DPTR,A
    539            pFrame[FRAME_DATA_OFFSET + ZB_RECV_SRC_OFFSET+ 1] = HI_UINT16(gtwData->source);
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F9           MOV     R1,A
   \   000047   E4           CLR     A
   \   000048   C9           XCH     A,R1
   \   000049   F8           MOV     R0,A
   \   00004A   E8           MOV     A,R0
   \   00004B   C0E0         PUSH    A
   \   00004D   7405         MOV     A,#0x5
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   D0E0         POP     A
   \   000054   F0           MOVX    @DPTR,A
    540          
    541            // Command ID
    542            pFrame[FRAME_DATA_OFFSET + ZB_RECV_CMD_OFFSET] = LO_UINT16(SENSOR_REPORT_CMD_ID);
   \   000055   7406         MOV     A,#0x6
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7402         MOV     A,#0x2
   \   00005C   F0           MOVX    @DPTR,A
    543            pFrame[FRAME_DATA_OFFSET + ZB_RECV_CMD_OFFSET+ 1] = HI_UINT16(SENSOR_REPORT_CMD_ID);
   \   00005D   7407         MOV     A,#0x7
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   7400         MOV     A,#0x0
   \   000064   F0           MOVX    @DPTR,A
    544          
    545            // Length
    546            pFrame[FRAME_DATA_OFFSET + ZB_RECV_LEN_OFFSET] = LO_UINT16(4);
   \   000065   7408         MOV     A,#0x8
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   7404         MOV     A,#0x4
   \   00006C   F0           MOVX    @DPTR,A
    547            pFrame[FRAME_DATA_OFFSET + ZB_RECV_LEN_OFFSET+ 1] = HI_UINT16(4);
   \   00006D   7409         MOV     A,#0x9
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   7400         MOV     A,#0x0
   \   000074   F0           MOVX    @DPTR,A
    548          
    549            // Data
    550            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET] = gtwData->temp;
   \   000075   8A82         MOV     DPL,R2
   \   000077   8B83         MOV     DPH,R3
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   C0E0         PUSH    A
   \   000080   740A         MOV     A,#0xa
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   D0E0         POP     A
   \   000087   F0           MOVX    @DPTR,A
    551            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET+ 1] = gtwData->voltage;
   \   000088   8A82         MOV     DPL,R2
   \   00008A   8B83         MOV     DPH,R3
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   C0E0         PUSH    A
   \   000094   740B         MOV     A,#0xb
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   D0E0         POP     A
   \   00009B   F0           MOVX    @DPTR,A
    552            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET+ 2] = LO_UINT16(gtwData->parent);
   \   00009C   8A82         MOV     DPL,R2
   \   00009E   8B83         MOV     DPH,R3
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F8           MOV     R0,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   F9           MOV     R1,A
   \   0000A7   E8           MOV     A,R0
   \   0000A8   C0E0         PUSH    A
   \   0000AA   740C         MOV     A,#0xc
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   D0E0         POP     A
   \   0000B1   F0           MOVX    @DPTR,A
    553            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET+ 3] = HI_UINT16(gtwData->parent);
   \   0000B2   8A82         MOV     DPL,R2
   \   0000B4   8B83         MOV     DPH,R3
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F8           MOV     R0,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   F9           MOV     R1,A
   \   0000BD   E4           CLR     A
   \   0000BE   C9           XCH     A,R1
   \   0000BF   F8           MOV     R0,A
   \   0000C0   E8           MOV     A,R0
   \   0000C1   C0E0         PUSH    A
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   D0E0         POP     A
   \   0000CA   F0           MOVX    @DPTR,A
    554          
    555            // Frame Check Sequence
    556            pFrame[ZB_RECV_LENGTH - 1] = calcFCS(&pFrame[FRAME_LENGTH_OFFSET], (ZB_RECV_LENGTH - 2) );
   \   0000CB                ; Setup parameters for call to function calcFCS
   \   0000CB   790D         MOV     R1,#0xd
   \   0000CD   7401         MOV     A,#0x1
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   AA82         MOV     R2,DPL
   \   0000D4   AB83         MOV     R3,DPH
   \   0000D6   12....       LCALL   `??calcFCS::?relay`  ; Banked call to: calcFCS
   \   0000D9   E9           MOV     A,R1
   \   0000DA   C0E0         PUSH    A
   \   0000DC   740E         MOV     A,#0xe
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   D0E0         POP     A
   \   0000E3   F0           MOVX    @DPTR,A
    557          
    558            // Write report to UART
    559            HalUARTWrite(HAL_UART_PORT_0,pFrame, ZB_RECV_LENGTH);
   \   0000E4                ; Setup parameters for call to function HalUARTWrite
   \   0000E4   7C0F         MOV     R4,#0xf
   \   0000E6   7D00         MOV     R5,#0x0
   \   0000E8   AA..         MOV     R2,?XSP + 0
   \   0000EA   AB..         MOV     R3,?XSP + 1
   \   0000EC   7900         MOV     R1,#0x0
   \   0000EE   12....       LCALL   `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    560          }
   \   0000F1   740F         MOV     A,#0xf
   \   0000F3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F6   D083         POP     DPH
   \   0000F8   D082         POP     DPL
   \   0000FA   02....       LJMP    ?BRET
    561          
    562          /******************************************************************************
    563           * @fn          calcFCS
    564           *
    565           * @brief       This function calculates the FCS checksum for the serial message
    566           *
    567           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
    568           *              len - Length of the pBuf.
    569           *
    570           * @return      The calculated FCS.
    571           ******************************************************************************
    572           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    573          static uint8 calcFCS(uint8 *pBuf, uint8 len)
   \                     calcFCS:
    574          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    575            uint8 rtrn = 0;
   \   000006   7900         MOV     R1,#0x0
   \   000008   8011         SJMP    ??calcFCS_0
    576          
    577            while ( len-- )
    578            {
    579              rtrn ^= *pBuf++;
   \                     ??calcFCS_1:
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   C9           XCH     A,R1
   \   000010   69           XRL     A,R1
   \   000011   C9           XCH     A,R1
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   AA82         MOV     R2,DPL
   \   000019   AB83         MOV     R3,DPH
    580            }
   \                     ??calcFCS_0:
   \   00001B   E8           MOV     A,R0
   \   00001C   FC           MOV     R4,A
   \   00001D   74FF         MOV     A,#-0x1
   \   00001F   2C           ADD     A,R4
   \   000020   F8           MOV     R0,A
   \   000021   EC           MOV     A,R4
   \   000022   70E6         JNZ     ??calcFCS_1
    581          
    582            return rtrn;
   \   000024   D083         POP     DPH
   \   000026   D082         POP     DPL
   \   000028   02....       LJMP    ?BRET
    583          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for myStartRetryDelay>`:
   \   000000   0A           DB 10

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for myDoorCheckDelay>`:
   \   000000   64           DB 100

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleOsalEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleOsalEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_StartConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_StartConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_SendDataConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_SendDataConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_BindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_BindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_AllowBindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_AllowBindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_FindDeviceConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_FindDeviceConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_ReceiveDataIndication::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??uartRxCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uartRxCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??sysPingReqRcvd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    sysPingReqRcvd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??sysPingRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    sysPingRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??sendGtwReport::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    sendGtwReport

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??calcFCS::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    calcFCS

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     15   calcFCS
      3     24   sendGtwReport
        2     15   -> HalUARTWrite
        2     15   -> calcFCS
      2    138   sysPingReqRcvd
        2      0   -> sysPingRsp
      3      7   sysPingRsp
        2      7   -> HalUARTWrite
        2      7   -> calcFCS
      0    138   uartRxCB
        0    138   -> HalUARTRead
        0    138   -> sysPingReqRcvd
      0      0   zb_AllowBindConfirm
      0      0   zb_BindConfirm
      0      0   zb_FindDeviceConfirm
      0     16   zb_HandleKeys
        0     12   -> HalLedSet
        0     16   -> osal_start_reload_timer
        0     12   -> zb_AllowBind
      0      9   zb_HandleOsalEvent
        0      9   -> HalLedBlink
        0      9   -> HalLedSet
        0      9   -> initUart
        0      9   -> osal_stop_timerEx
        0      9   -> zb_StartRequest
      0     13   zb_ReceiveDataIndication
        0      9   -> HalLedSet
        0      9   -> sendGtwReport
      0      0   zb_SendDataConfirm
      0     16   zb_StartConfirm
        0     12   -> HalLedSet
        0     16   -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for myDoorCheckDelay>
       1  ?<Initializer for myStartRetryDelay>
       1  P0DIR
       1  P1DIR
       1  _A_P0
       1  _A_P1
       1  allowBind
       1  appState
      43  calcFCS
       6  calcFCS::?relay
       6  gtwData
       1  myDoorCheckDelay
       1  myStartRetryDelay
       1  prevDoorCheckVal
     253  sendGtwReport
       6  sendGtwReport::?relay
      14  sysPingReqRcvd
       6  sysPingReqRcvd::?relay
     108  sysPingRsp
       6  sysPingRsp::?relay
     103  uartRxCB
       6  uartRxCB::?relay
       3  zb_AllowBindConfirm
       6  zb_AllowBindConfirm::?relay
       3  zb_BindConfirm
       6  zb_BindConfirm::?relay
       3  zb_FindDeviceConfirm
       6  zb_FindDeviceConfirm::?relay
     140  zb_HandleKeys
       6  zb_HandleKeys::?relay
     137  zb_HandleOsalEvent
       6  zb_HandleOsalEvent::?relay
       2  zb_InCmdList
     100  zb_ReceiveDataIndication
       6  zb_ReceiveDataIndication::?relay
       3  zb_SendDataConfirm
       6  zb_SendDataConfirm::?relay
      12  zb_SimpleDesc
      67  zb_StartConfirm
       6  zb_StartConfirm::?relay

 
 977 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
   4 bytes in segment SFR_AN
   2 bytes in segment XDATA_I
   2 bytes in segment XDATA_ID
  14 bytes in segment XDATA_ROM_C
   9 bytes in segment XDATA_Z
 
 1 057 bytes of CODE  memory
    14 bytes of CONST memory
     0 bytes of DATA  memory (+ 4 bytes shared)
    11 bytes of XDATA memory

Errors: none
Warnings: none
